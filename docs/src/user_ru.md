``` @meta
CurrentModule = PkgTemplates
```

# Руководство пользователя PkgTemplates

``` @contents
Pages = ["user.md"]
```

Использовать [PkgTemplates](https://github.com/JuliaCI/PkgTemplates.jl/) просто. Просто создайте [Шаблон](@ref) (Template) и вызовите его по имени пакета, чтобы сгенерировать этот пакет::

``` julia
using PkgTemplates
t = Template()
t("MyPkg")
```

## Шаблон

``` @docs
Template
generate
```

## Плагины

Плагины добавляют функциональность Шаблонам (`Template`). Существует ряд доступных плагинов для автоматизации типовых задач.

### Плагины по умолчанию

Эти плагины включены по умолчанию. Они могут быть переопределены путем указания другого значения или отключены путем отрицания типа (`!Type`), оба как элементы ключевого слова `plugins`.

``` @docs
ProjectFile
SrcDir
Tests
Readme
License
Git
GitHubActions
CompatHelper
TagBot
Secret
Dependabot
```

### Continuous Integration (CI)

Эти плагины создадут для вас файлы конфигурации общих служб CI.

``` @docs
AppVeyor
CirrusCI
DroneCI
GitLabCI
TravisCI
```

### Code Coverage

Эти плагины позволят создавать отчеты о покрытии кода из CI.

``` @docs
Codecov
Coveralls
```

### Documentation

Эти плагины помогут вам создать веб-сайт с документацией.

``` @docs
Documenter
Logo
```

### Badges

Эти плагины добавят значки в README.

``` @docs
BlueStyleBadge
ColPracBadge
PkgEvalBadge
```

### Miscellaneous

``` @docs
Develop
Citation
RegisterAction
Formatter
CodeOwners
PkgBenchmark
```

## Более сложный пример

Вот несколько примеров шаблонов, в которых используются опции и плагины, описанные выше.

Он включает в себя плагины, подходящие для проекта, размещенного на GitHub, и некоторые другие настройки:

``` julia
Template(;
    user="my-username",
    dir="~/code",
    authors="Acme Corp",
    julia=v"1.1",
    plugins=[
        License(; name="MPL"),
        Git(; manifest=true, ssh=true),
        GitHubActions(; x86=true),
        Codecov(),
        Documenter{GitHubActions}(),
        Develop(),
    ],
)
```

Вот один из них, который хорошо работает для проектов, размещенных на GitLab:

``` julia
Template(;
    user="my-username",
    host="gitlab.com",
    plugins=[
        GitLabCI(),
        Documenter{GitLabCI}(),
    ],
)
```

## Пользовательские Файлы Шаблонов

!!! примечание "Шаблоны vs Создания шаблонов" В этой документации много говорится о [Шаблонах](@ref), основном типе пакета, но в ней также говорится о "файлах шаблонов" и "текстовых шаблонах", которые представляют собой текстовые файлы с заполнителями, которые должны быть заполнены данными, и о технике заполнения этих заполнителей данными, соответственно.

```         
Эти понятия должны быть знакомы, если вы использовали [Jinja](https://palletsprojects.com/p/jinja) или [Mustache](https://mustache.github.io) (Mustache - это особый подход, используемый PkgTemplates, через [Mustache.jl](https://github.com/jverzani/Mustache.jl)).
Пожалуйста, имейте в виду разницу между этими двумя понятиями!
```

Многие плагины поддерживают аргумент `file` или аналогичный, который задает путь к файлу шаблона, который будет использоваться для создания файлов. У каждого плагина есть разумное значение по умолчанию, которое должно иметь смысл для большинства людей, но у вас может быть специализированный рабочий процесс, для которого требуется совершенно другой файл шаблона.

В этом случае требуется базовое понимание синтаксиса [Mustache](https://mustache.github.io). Вот пример файла шаблона:

```         
Hello, {{{name}}}.

{{#weather}}
It's {{{weather}}} outside.
{{/weather}}
{{^weather}}
I don't know what the weather outside is.
{{/weather}}

{{#has_things}}
I have the following things:
{{/has_things}}
{{#things}}
- Here's a thing: {{{.}}}
{{/things}}

{{#people}}
- {{{name}}} is {{{mood}}}
{{/people}}
```

В первом разделе `name` является ключом, и его значение заменяет `{{{name}}}`.

Во втором разделе значение `weather` может существовать, а может и не существовать. Если оно существует, то печатается "\$weather на улице". В противном случае печатается "Я не знаю, какая погода на улице". Mustache использует понятие "правдивости", аналогичное Python или JavaScript, где значения `nothing`, `false` или пустые коллекции считаются несуществующими.

В третьем разделе значение `has_things` печатается, если оно истинно. Затем, если список `things` является истинным (т.е. не пустым), каждое из его значений печатается в отдельной строке. Причина, по которой у нас есть два отдельных ключа, заключается в том, что `{{#things}}` выполняется итерация по всему списку `things`, даже если нет `{{{.}}}` заполнителей, которые дублировали бы "У меня есть следующие вещи:" `n` раз.

В четвертом разделе мы перебираем список `people`, но вместо использования заполнителя `{{{.}}}` у нас есть имя `name` и настроение `mood`, которые являются ключами или полями элементов списка. Здесь поддерживается большинство типов, включая `Dict` и структуры. Однако `NamedTuple` требуют, чтобы вы использовали `{{{:name}}}` вместо обычного `{{{name}}}`.

Вы могли бы заметить, что некоторые завитки находятся в группах по два (`{{key}}`), а некоторые - в группах по три (`{{{key}}}`). Всякий раз, когда мы хотим подставить значение, использование тройных завитков отключает экранирование HTML, которое мы редко используем для типов файлов, которые мы создаем. Если вы хотите экранировать, просто используйте двойные завитки. И если вы используете разные разделители, например `<<foo>>`, используйте `<<&foo>>`, чтобы отключить экранирование.

Предполагая следующую точку зрения:

``` julia
struct Person; name::String; mood::String; end
things = ["a", "b", "c"]
view = Dict(
    "name" => "Chris",
    "weather" => "sunny",
    "has_things" => !isempty(things),
    "things" => things,
    "people" => [Person("John", "happy"), Person("Jane", "sad")],
)
```

Наш пример шаблона привел бы к такому результату:

```         
Hello, Chris.

It's sunny outside.

I have the following things:
- Here's a thing: a
- Here's a thing: b
- Here's a thing: c

- John is happy
- Jane is sad
```

## Расширение существующих плагинов

Большинство существующих плагинов генерируют файл из файла шаблона. Если вы хотите использовать пользовательские файлы шаблонов, вы можете столкнуться с ситуациями, когда данных, переданных в механизм создания шаблонов, недостаточно. В этом случае вы можете изучить реализацию [`user_view`](@ref), чтобы предоставить любые данные, необходимые для вашего варианта использования.

``` @docs
user_view
```

Например, предположим, что вы использовали плагин [`Readme`](@ref) с пользовательским файлом шаблона, который выглядел следующим образом:

``` md
# {{PKG}}

Created on *{{TODAY}}*.
```

Функция [`view`](@ref) предоставляет значение для `PKG`, но она не предоставляет значение на сегодняшний `TODAY`. Вместо того, чтобы переопределять [`view`](@ref), мы можем реализовать эту функцию, чтобы получить как значения по умолчанию, так и все остальное, что нам нужно добавить.

``` julia
user_view(::Readme, ::Template, ::AbstractString) = Dict("TODAY" => today())
```

## Сохранение Шаблонов

Одна из основных причин существования PkgTemplates заключается в том, что новые пакеты должны быть согласованными. Это означает использование одного и того же шаблона более одного раза, поэтому нам нужен способ сохранить шаблон для последующего использования.

Вот моя рекомендация по загрузке шаблона всякий раз, когда это необходимо:

``` julia
function template()
    @eval begin
        using PkgTemplates
        Template(; #= ... =#)
    end
end
```

Добавьте это в свой `startup.jl`, и вы сможете создать свой шаблон из любого места, не неся никаких затрат на запуск.

Другая стратегия заключается в записи строкового представления шаблона в файл Julia:

``` julia
const t = Template(; #= ... =#)
open("template.jl", "w") do io
    println(io, "using PkgTemplates")
    print(io, t)
end
```

Тогда шаблон - это просто подключение внешних источников через директиву `include` :

``` julia
const t = include("template.jl")
```

Единственным недостатком такого подхода является то, что сохраненный шаблон гораздо менее удобочитаем, чем код, который вы написали сами.

Еще один способ сохранения шаблонов - просто использовать пакет Serialization в стандартной библиотеке:

``` julia
const t = Template(; #= ... =#)
using Serialization
open(io -> serialize(io, t), "template.bin", "w")
```

Затем очень просто загрузить через `deserialize`:

``` julia
using Serialization
const t = open(deserialize, "template.bin")
```

Этот подход имеет тот же недостаток, что и предыдущий, и не гарантируется стабильность формата сериализации во всех версиях Julia.